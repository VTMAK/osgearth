/* -*-c++-*- */
/* osgEarth - Geospatial SDK for OpenSceneGraph
 * Copyright 2018 Pelican Mapping
 * http://osgearth.org
 *
 * osgEarth is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 */
#ifndef OSGEARTH_IMGUI_UTILS_H
#define OSGEARTH_IMGUI_UTILS_H 1

#include "GL/glew.h"
#include "imgui.h"

#include <osg/OperationThread>
#include <osg/GraphicsContext>
#include <osg/Notify>
#include <osgEarth/MapNode>
#include <osgEarth/VisibleLayer>
#include <osgEarth/EarthManipulator>
#include <osgEarth/ImageLayer>
#include <osgEarth/ThreeDTilesLayer>
#include <osgEarth/Threading>
#include <osgEarth/Utils>
#include <osgEarth/Geocoder>
#include <osgEarth/ViewFitter>
#include <osgEarth/NetworkMonitor>
#include <osgEarth/AnnotationUtils>
#include <osg/PolygonMode>


using namespace osgEarth;
using namespace osgEarth::Threading;
using namespace ImGui;

namespace osgEarth {
    namespace ImGuiUtil {

        class GlewInitOperation : public osg::Operation
        {
        public:
            GlewInitOperation()
                : osg::Operation("GlewInitCallback", false)
            {
            }

            void operator()(osg::Object* object) override
            {
                osg::GraphicsContext* context = dynamic_cast<osg::GraphicsContext*>(object);
                if (!context)
                {
                    return;
                }

                if (glewInit() != GLEW_OK)
                {
                    OSG_FATAL << "glewInit() failed" << std::endl;
                }
            }
        };

        static void Texture(osg::Texture2D* texture, osg::RenderInfo& renderInfo, unsigned int width = 0, unsigned int height = 0)
        {
            // Get the context id
            const unsigned int contextID = renderInfo.getState()->getContextID();

            // Apply the texture
            texture->apply(*renderInfo.getState());

            // Default to the textures size
            unsigned int w = texture->getTextureWidth();
            unsigned int h = texture->getTextureHeight();

            // Get the aspect ratio
            double ar = (double)w / (double)h;

            // If both width and height are specified use that.
            if (width != 0 && height != 0)
            {
                w = width;
                h = height;
            }
            // If just the width is specified compute the height using the ar
            else if (width != 0)
            {
                w = width;
                h = (1.0 / ar) * w;
            }
            // If just the height is specified compute the width using the ar
            else if (height != 0)
            {
                h = height;
                w = ar * height;
            }

            // Get the TextureObject.
            osg::Texture::TextureObject* textureObject = texture->getTextureObject(contextID);
            if (textureObject)
            {

                //double h = 100.0;
                //double w = ar * h;
                ImGui::Image((void*)(intptr_t)textureObject->_id, ImVec2(w, h), ImVec2(0, 1), ImVec2(1, 0));
            }
        }

        class ImGuiNotifyHandler : public osg::NotifyHandler
        {
        public:
            void notify(osg::NotifySeverity severity, const char *message)
            {
                ScopedMutexLock lk(_mutex);
                int old_size = Buf.size();
                Buf.append(message);
                for (int new_size = Buf.size(); old_size < new_size; old_size++)
                    if (Buf[old_size] == '\n')
                        LineOffsets.push_back(old_size + 1);
            }

            void    Clear()
            {
                Buf.clear();
                LineOffsets.clear();
                LineOffsets.push_back(0);
            }

            Mutex _mutex;
            ImGuiTextBuffer     Buf;
            ImVector<int>       LineOffsets;        // Index to lines offset. We maintain this with AddLog() calls, allowing us to have a random access on lines
        };

        struct LogGUI
        {
            LogGUI()
            {
                _handler = dynamic_cast<ImGuiNotifyHandler*>(osg::getNotifyHandler());
            }

            void draw(bool *show)
            {
                if (_handler)
                {
                    if (ImGui::Begin("Log", show))
                    {

                        bool clear = ImGui::Button("Clear");
                        ImGui::SameLine();
                        Filter.Draw("Filter", -100.0f);

                        ImGui::Separator();
                        ImGui::BeginChild("scrolling", ImVec2(0, 0), false, ImGuiWindowFlags_HorizontalScrollbar);

                        if (clear)
                            _handler->Clear();

                        ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0, 0));
                        const char* buf = _handler->Buf.begin();
                        const char* buf_end = _handler->Buf.end();

                        if (Filter.IsActive())
                        {
                            // In this example we don't use the clipper when Filter is enabled.
                            // This is because we don't have a random access on the result on our filter.
                            // A real application processing logs with ten of thousands of entries may want to store the result of search/filter.
                            // especially if the filtering function is not trivial (e.g. reg-exp).
                            for (int line_no = 0; line_no < _handler->LineOffsets.Size; line_no++)
                            {
                                const char* line_start = buf + _handler->LineOffsets[line_no];
                                const char* line_end = (line_no + 1 < _handler->LineOffsets.Size) ? (buf + _handler->LineOffsets[line_no + 1] - 1) : buf_end;
                                if (Filter.PassFilter(line_start, line_end))
                                    ImGui::TextUnformatted(line_start, line_end);
                            }
                        }
                        else
                        {
                            // The simplest and easy way to display the entire buffer:
                            //   ImGui::TextUnformatted(buf_begin, buf_end);
                            // And it'll just work. TextUnformatted() has specialization for large blob of text and will fast-forward to skip non-visible lines.
                            // Here we instead demonstrate using the clipper to only process lines that are within the visible area.
                            // If you have tens of thousands of items and their processing cost is non-negligible, coarse clipping them on your side is recommended.
                            // Using ImGuiListClipper requires A) random access into your data, and B) items all being the  same height,
                            // both of which we can handle since we an array pointing to the beginning of each line of text.
                            // When using the filter (in the block of code above) we don't have random access into the data to display anymore, which is why we don't use the clipper.
                            // Storing or skimming through the search result would make it possible (and would be recommended if you want to search through tens of thousands of entries)
                            ImGuiListClipper clipper;
                            clipper.Begin(_handler->LineOffsets.Size);
                            while (clipper.Step())
                            {
                                for (int line_no = clipper.DisplayStart; line_no < clipper.DisplayEnd; line_no++)
                                {
                                    const char* line_start = buf + _handler->LineOffsets[line_no];
                                    const char* line_end = (line_no + 1 < _handler->LineOffsets.Size) ? (buf + _handler->LineOffsets[line_no + 1] - 1) : buf_end;
                                    ImGui::TextUnformatted(line_start, line_end);
                                }
                            }
                            clipper.End();
                        }
                        ImGui::PopStyleVar();

                        if (ImGui::GetScrollY() >= ImGui::GetScrollMaxY())
                            ImGui::SetScrollHereY(1.0f);

                        ImGui::EndChild();
                        ImGui::End();
                    }
                }
            }

            ImGuiNotifyHandler* _handler;
            ImGuiTextFilter     Filter;
        };

        class NetworkMonitorGUI
        {
        public:
            NetworkMonitorGUI() :
                _showOnlyActiveRequests(false),
                filter("")
            {

            }

            void draw(bool *show)
            {
                if (ImGui::Begin("Network Monitor", show))
                {
                    NetworkMonitor::setEnabled(true);

                    NetworkMonitor::Requests requests;
                    NetworkMonitor::getRequests(requests);

                    // Compute the time duration for all of the requests
                    osg::Timer_t startTime;
                    double totalTime = 0.0;
                    if (!requests.empty())
                    {
                        startTime = requests.begin()->second.startTime;
                        if (requests.rbegin()->second.isComplete)
                        {
                            totalTime = osg::Timer::instance()->delta_m(startTime, requests.rbegin()->second.endTime);
                        }
                        else
                        {
                            totalTime = osg::Timer::instance()->delta_m(startTime, osg::Timer::instance()->tick());
                        }
                    }

                    if (ImGui::Button("Save"))
                    {
                        NetworkMonitor::saveCSV(requests, "network_requests.csv");
                    }

                    ImGui::Checkbox("Show active requests", &_showOnlyActiveRequests);

                    ImGui::InputText("Filter", filter, 128);

                    if (ImGui::Button("Clear"))
                    {
                        NetworkMonitor::clear();
                    }

                    ImGui::Text("%d requests", requests.size()); ImGui::SameLine();
                    ImGui::Text("Finished %f s", totalTime / 1000.0);

                    ImGui::BeginChild("Columns");
                    ImGui::Columns(7, "requests");
                    ImGui::Separator();
                    ImGui::Text("Path"); ImGui::NextColumn();
                    ImGui::Text("Duration"); ImGui::NextColumn();
                    ImGui::Text("Start time"); ImGui::NextColumn();
                    ImGui::Text("End time"); ImGui::NextColumn();
                    ImGui::Text("Layer"); ImGui::NextColumn();
                    ImGui::Text("Type"); ImGui::NextColumn();
                    ImGui::Text("Status"); ImGui::NextColumn();
                    ImGui::Separator();


                    std::string filterLower = osgEarth::toLower(filter);

                    for (NetworkMonitor::Requests::iterator itr = requests.begin(); itr != requests.end(); ++itr)
                    {
                        if (!_showOnlyActiveRequests || !itr->second.isComplete)
                        {
                            if (!filterLower.empty())
                            {
                                std::string uriLower = osgEarth::toLower(itr->second.uri);
                                std::string statusLower = osgEarth::toLower(itr->second.status);
                                std::string layerLower = osgEarth::toLower(itr->second.layer);
                                std::string typeLower = osgEarth::toLower(itr->second.type);

                                if (strstr(uriLower.c_str(), filterLower.c_str()) == NULL &&
                                    strstr(statusLower.c_str(), filterLower.c_str()) == NULL &&
                                    strstr(layerLower.c_str(), filterLower.c_str()) == NULL &&
                                    strstr(typeLower.c_str(), filterLower.c_str()) == NULL)
                                {
                                    continue;
                                }
                            }

                            ImVec4 color = ImVec4(1.0, 1.0, 1.0, 1.0);
                            if (itr->second.isComplete)
                            {
                                if (strstr(itr->second.status.c_str(), "OK") != NULL)
                                {
                                    // Color OK requests green
                                    color = ImVec4(0.0, 1.0, 0.0, 1.0);
                                }
                                else
                                {
                                    // Color bad requests red
                                    color = ImVec4(1.0, 0.0, 0.0, 1.0);
                                }
                            }

                            double startMS = osg::Timer::instance()->delta_m(startTime, itr->second.startTime);
                            double endMS = 0.0;
                            if (itr->second.isComplete)
                            {
                                endMS = osg::Timer::instance()->delta_m(startTime, itr->second.endTime);
                            }
                            else
                            {
                                endMS = osg::Timer::instance()->delta_m(startTime, osg::Timer::instance()->tick());
                            }

                            ImGui::TextColored(color, itr->second.uri.c_str());  ImGui::NextColumn();
                            ImGui::Text("%.2lf ms", itr->second.getDuration()); ImGui::NextColumn();
                            ImGui::Text("%.2lf ms", startMS); ImGui::NextColumn();
                            ImGui::Text("%.2lf ms", endMS); ImGui::NextColumn();
                            ImGui::Text(itr->second.layer.c_str()); ImGui::NextColumn();
                            ImGui::Text(itr->second.type.c_str()); ImGui::NextColumn();
                            ImGui::Text(itr->second.status.c_str()); ImGui::NextColumn();
                        }
                    }
                    ImGui::Columns(1);
                    ImGui::Separator();

                    // Keep scroll position at the bottom so we can see new network requests as they come in if they are scrolled to the bottom already
                    if (ImGui::GetScrollY() == ImGui::GetScrollMaxY())
                    {
                        ImGui::SetScrollHere(1.0);
                    }
                    ImGui::EndChild();

                    ImGui::End();
                }
                else
                {
                    NetworkMonitor::setEnabled(false);
                }
            }

            bool _showOnlyActiveRequests;
            char filter[128];
        };

        class SearchGUI
        {
        public:
            SearchGUI() :
                _search(""),
                _results(Status::Code::ServiceUnavailable, 0)
            {
                _options = new osgDB::Options();
                arena = std::make_shared<JobArena>("Geocoder", 1U);
                ObjectStorage::set(_options.get(), arena);
            }

            void draw(EarthManipulator* manip)
            {
                //ImGui::Begin("Search");
                if (ImGui::InputText("Search", _search, 128, ImGuiInputTextFlags_EnterReturnsTrue | ImGuiInputTextFlags_AutoSelectAll))
                {
                    _features.clear();
                    _results = geocoder.search(_search, _options.get());
                }

                if (_results.isReady())
                {
                    if (_results.getStatus().isOK())
                    {
                        _results.getFeatures()->fill(_features);
                    }
                    _results = Geocoder::Results(Status::Code::ServiceUnavailable, 0);
                }

                ImGui::BeginGroup();
                ImGui::BeginChild("Results", ImVec2(0, 100.0f));
                for (FeatureList::iterator itr = _features.begin(); itr != _features.end(); ++itr)
                {
                    bool selected = false;
                    Feature* feature = itr->get();
                    if (feature->getGeometry())
                    {
                        std::string displayName = itr->get()->getString("display_name");
                        ImGui::Selectable(displayName.c_str(), &selected);
                        if (selected)
                        {
                            GeoExtent extent(feature->getSRS(), feature->getGeometry()->getBounds());
                            double maxDim = osg::maximum(extent.width(), extent.height());
                            double range = ((0.5 * maxDim) / 0.267949849) * 111000.0;
                            double lon, lat;
                            extent.getCentroid(lon, lat);
                            manip->setViewpoint(Viewpoint("", lon, lat, 0, 0, -90, range), 3.0);
                            _features.clear();
                            break;
                        }
                    }
                }
                ImGui::EndChild();
                ImGui::EndGroup();
                //ImGui::End();
            }

            char _search[128];
            Geocoder::Results _results;
            osg::ref_ptr<osgDB::Options> _options;
            std::shared_ptr<JobArena> arena;
            FeatureList _features;
            Geocoder geocoder;
        };

        class FindTexturesVisitor : public osg::NodeVisitor
        {
        public:
            FindTexturesVisitor() :
                osg::NodeVisitor(osg::NodeVisitor::TRAVERSE_ALL_CHILDREN)
            {
            }

            void apply(osg::Node& node)
            {
                auto stateset = node.getStateSet();
                if (stateset)
                {
                    for (unsigned int i = 0; i < stateset->getTextureAttributeList().size(); ++i)
                    {
                        osg::Texture2D* texture = dynamic_cast<osg::Texture2D*>(stateset->getTextureAttribute(i, osg::StateAttribute::TEXTURE));
                        if (texture)
                        {
                            _textures.insert(texture);
                        }
                    }
                }
                traverse(node);
            }

            typedef std::set< osg::ref_ptr< osg::Texture2D > > TextureSet;
            TextureSet _textures;
        };

        class TextureInspectorGUI
        {
        public:
            void draw(osg::RenderInfo& renderInfo, osg::Node* root, bool *show)
            {
                if (ImGui::Begin("Texture Inspector", show))
                {
                    if (ImGui::Button("Refresh"))
                    {
                        _textures.clear();
                            FindTexturesVisitor findTextures;
                            root->accept(findTextures);
                            std::copy(findTextures._textures.begin(), findTextures._textures.end(), std::back_inserter(_textures));
                    }
                    ImGui::Text("Found %d textures", _textures.size());
                        ImGuiStyle& style = ImGui::GetStyle();
                        float window_visible_x2 = ImGui::GetWindowPos().x + ImGui::GetWindowContentRegionMax().x;
                    unsigned int textureWidth = 50;
                    for (unsigned int i = 0; i < _textures.size(); ++i)
                    {
                        auto t = _textures[i];
                        std::string name = t.get()->getName();
                        if (name.empty())
                        {
                            name = "Texture";
                        }

                        ImGui::PushID(t.get());
                        ImGui::BeginGroup();
                        ImGui::Text(name.c_str());
                        ImGuiUtil::Texture(t.get(), renderInfo, textureWidth);
                        ImGui::EndGroup();

                        float last_button_x2 = ImGui::GetItemRectMax().x;
                        float next_button_x2 = last_button_x2 + style.ItemSpacing.x + textureWidth; // Expected position if next button was on same line
                        if (i + 1 < _textures.size() && next_button_x2 < window_visible_x2)
                            ImGui::SameLine();

                        ImGui::PopID();
                        if (ImGui::IsItemHovered())
                        {
                            ImGui::BeginTooltip();
                            ImGui::Text("%dx%d", t.get()->getTextureWidth(), t.get()->getTextureHeight());
                            osg::Image* image = t.get()->getImage();
                            if (image && !image->getFileName().empty())
                            {
                                ImGui::Text(image->getFileName().c_str());
                            }
                            ImGui::EndTooltip();
                        }

                    }
                    ImGui::End();
                }
            }

            std::vector< osg::ref_ptr< osg::Texture2D > > _textures;
        };


        // Manages the single selected node in the application.
        static osg::ref_ptr< osg::Node > s_selectedNode;

        static osg::Node* getSelectedNode()
        {
            return s_selectedNode.get();
        }

        static void setSelectedNode(osg::Node* node)
        {
            s_selectedNode = node;
        }



        class SceneHierarchy
        {
        public:

            class SceneHierarchyVisitor : public osg::NodeVisitor
            {
            public:
                SceneHierarchyVisitor() :
                    osg::NodeVisitor(osg::NodeVisitor::TRAVERSE_ALL_CHILDREN)
                {
                }

                void apply(osg::Node& node)
                {
                    // Non groups act as leaf nodes
                    std::string label = getLabel(node);
                    ImGuiTreeNodeFlags node_flags = base_flags;
                    node_flags |= ImGuiTreeNodeFlags_Leaf | ImGuiTreeNodeFlags_NoTreePushOnOpen;
                    if (getSelectedNode() == &node)
                    {
                        node_flags |= ImGuiTreeNodeFlags_Selected;
                    }

                    ImGui::TreeNodeEx(&node, node_flags, label.c_str());
                    if (ImGui::IsItemClicked())
                    {
                        setSelectedNode(&node);
                    }
                }

                void apply(osg::Group& node)
                {
                    std::string label = getLabel(node);
                    ImGuiTreeNodeFlags node_flags = base_flags;
                    if (getSelectedNode() == &node)
                    {
                        node_flags |= ImGuiTreeNodeFlags_Selected;
                    }

                    if (isInSelectedNodePath(&node))
                    {
                        ImGui::SetNextItemOpen(true, ImGuiCond_Once);
                    }

                    bool node_open = ImGui::TreeNodeEx(&node, node_flags, label.c_str());
                    if (ImGui::IsItemClicked())
                    {
                        setSelectedNode(&node);
                    }
                    if (node_open)
                    {
                        traverse(node);
                        ImGui::TreePop();
                    }
                }

                std::string getLabel(osg::Node& node)
                {
                    std::stringstream buf;
                    buf << node.getName() << " (" << typeid(node).name() << ")";

                    return buf.str();
                }

                bool isInSelectedNodePath(osg::Node* node)
                {
                    if (_selectedNodePaths.empty() && getSelectedNode())
                    {
                        _selectedNodePaths = getSelectedNode()->getParentalNodePaths();
                    }

                    for (unsigned int i = 0; i < _selectedNodePaths.size(); i++)
                    {
                        for (unsigned int j = 0; j < _selectedNodePaths[i].size(); j++)
                        {
                            if (node == _selectedNodePaths[i][j])
                            {
                                return true;
                            }
                        }
                    }
                    return false;
                }

                ImGuiTreeNodeFlags base_flags = ImGuiTreeNodeFlags_OpenOnArrow | ImGuiTreeNodeFlags_OpenOnDoubleClick | ImGuiTreeNodeFlags_SpanAvailWidth;
                osg::NodePathList _selectedNodePaths;
            };

            SceneHierarchy() :
                _selectedBounds(0)
            {
            }

            void draw(osg::Node* node, osg::RenderInfo& renderInfo, EarthManipulator* manip, MapNode* mapNode, bool *show)
            {
                if (ImGui::Begin("Scene Hierarchy", show))
                {
                    auto size = ImGui::GetWindowSize();

                    if (ImGui::CollapsingHeader("Scene"))
                    {
                        ImGui::BeginChild("Scene", ImVec2(0, 0.6f * size.y));
                        SceneHierarchyVisitor v;
                        node->accept(v);

                        ImGui::EndChild();
                    }

                    if (getSelectedNode())
                    {
                        if (ImGui::CollapsingHeader("Properties"))
                        {
                            ImGui::BeginChild("Properties");
                            properties(getSelectedNode(), renderInfo, manip, mapNode);
                            ImGui::EndChild();
                        }
                    }
                    ImGui::End();
                }
                // If they closed the tool deselect the node.
                if (!*show && getSelectedNode())
                {
                    setSelectedNode(nullptr);
                }
                updateBoundsDebug(mapNode);

            }

            void updateBoundsDebug(MapNode* mapNode)
            {
                if (_selectedBounds)
                {
                    mapNode->removeChild(_selectedBounds);
                    _selectedBounds = nullptr;
                }

                auto selectedNode = getSelectedNode();

                if (selectedNode)
                {
                    osg::NodePath nodePath = selectedNode->getParentalNodePaths()[0];
                    osg::Matrixd localToWorld = osg::computeLocalToWorld(nodePath);

                    osg::Drawable* drawable = selectedNode->asDrawable();
                    if (drawable)
                    {
                        osg::BoundingBoxd bb = drawable->getBoundingBox();
                        if (bb.valid())
                        {
                            _selectedBounds = new osg::MatrixTransform;
                            _selectedBounds->setName("Bounds");
                            _selectedBounds->setMatrix(localToWorld);
                            _selectedBounds->addChild(AnnotationUtils::createBoundingBox(bb, Color::Yellow));
                            mapNode->addChild(_selectedBounds);

                        }
                    }
                    else
                    {
                        osg::BoundingSphered bs = osg::BoundingSphered(selectedNode->getBound().center(), selectedNode->getBound().radius());
                        if (bs.radius() > 0)
                        {
                            _selectedBounds = new osg::MatrixTransform;
                            _selectedBounds->setName("Bounds");
                            _selectedBounds->setMatrix(localToWorld);
                            _selectedBounds->addChild(AnnotationUtils::createSphere(selectedNode->getBound().radius(), Color::Yellow));
                            _selectedBounds->getOrCreateStateSet()->setAttributeAndModes(new osg::PolygonMode(osg::PolygonMode::FRONT_AND_BACK, osg::PolygonMode::LINE), 1);
                            mapNode->addChild(_selectedBounds);
                        }
                    }
                }
            }


            void properties(osg::Node* node, osg::RenderInfo& renderInfo, EarthManipulator* manip, MapNode* mapNode)
            {
                if (ImGui::Button("Zoom to"))
                {
                    osg::NodePath nodePath = node->getParentalNodePaths()[0];
                    osg::Matrixd localToWorld = osg::computeLocalToWorld(nodePath);

                    osg::BoundingSphered& bs = osg::BoundingSphered(node->getBound().center(), node->getBound().radius());
                    if (bs.valid())
                    {
                        bs.center() += localToWorld.getTrans();
                        osg::Vec3d c = bs.center();
                        double r = bs.radius();
                        const SpatialReference* mapSRS = mapNode->getMap()->getSRS();

                        std::vector<GeoPoint> points;
                        GeoPoint p;
                        p.fromWorld(mapSRS, osg::Vec3d(c.x() + r, c.y(), c.z())); points.push_back(p);
                        p.fromWorld(mapSRS, osg::Vec3d(c.x() - r, c.y(), c.z())); points.push_back(p);
                        p.fromWorld(mapSRS, osg::Vec3d(c.x(), c.y() + r, c.z())); points.push_back(p);
                        p.fromWorld(mapSRS, osg::Vec3d(c.x(), c.y() - r, c.z())); points.push_back(p);
                        p.fromWorld(mapSRS, osg::Vec3d(c.x(), c.y(), c.z() + r)); points.push_back(p);
                        p.fromWorld(mapSRS, osg::Vec3d(c.x(), c.y(), c.z() - r)); points.push_back(p);

                        ViewFitter fitter(mapNode->getMap()->getSRS(), renderInfo.getCurrentCamera());
                        Viewpoint vp;
                        if (fitter.createViewpoint(points, vp))
                        {
                            manip->setViewpoint(vp, 2.0);
                        }
                    }
                }

                if (ImGui::TreeNode("General"))
                {
                    ImGui::Text("Type %s", typeid(*node).name());
                    ImGui::Text("Name %s", node->getName().c_str());
                    ImGui::TreePop();
                }

                osg::MatrixTransform* matrixTransform = dynamic_cast<osg::MatrixTransform*>(node);
                if (matrixTransform)
                {
                    if (ImGui::TreeNode("Transform"))
                    {
                        bool dirty = false;
                        osg::Matrix matrix = matrixTransform->getMatrix();
                        osg::Vec3d translate = matrixTransform->getMatrix().getTrans();
                        if (ImGui::InputScalarN("Translation", ImGuiDataType_Double, translate._v, 3))
                        {
                            dirty = true;
                        }

                        osg::Vec3d scale = matrixTransform->getMatrix().getScale();
                        if (ImGui::InputScalarN("Scale", ImGuiDataType_Double, scale._v, 3))
                        {
                            dirty = true;
                        }
                        osg::Quat rot = matrixTransform->getMatrix().getRotate();
                        if (ImGui::InputScalarN("Rotation", ImGuiDataType_Double, rot._v, 4))
                        {
                            dirty = true;
                        }

                        if (dirty)
                        {
                            osg::Matrix newMatrix = osg::Matrix::translate(translate) * osg::Matrix::rotate(rot) * osg::Matrixd::scale(scale);
                            matrixTransform->setMatrix(newMatrix);
                        }
                        ImGui::TreePop();
                    }
                }

                osg::StateSet* stateset = node->getStateSet();
                if (stateset)
                {
                    if (ImGui::TreeNode("State Set"))
                    {
                        if (!stateset->getTextureAttributeList().empty() && ImGui::TreeNode("Textures"))
                        {
                            unsigned int textureWidth = 50;
                            for (unsigned int i = 0; i < stateset->getTextureAttributeList().size(); ++i)
                            {
                                osg::Texture2D* texture = dynamic_cast<osg::Texture2D*>(stateset->getTextureAttribute(i, osg::StateAttribute::TEXTURE));

                                if (texture)
                                {
                                    ImGui::PushID(texture);
                                    ImGui::BeginGroup();
                                    ImGui::Text("Unit %d", i);
                                    ImGui::Text("Name %s", texture->getName().c_str());
                                    ImGuiUtil::Texture(texture, renderInfo, textureWidth);
                                    ImGui::EndGroup();
                                }
                            }
                            ImGui::TreePop();
                        }

                        VirtualProgram* virtualProgram = VirtualProgram::get(stateset);
                        if (virtualProgram && ImGui::TreeNode("Shaders"))
                        {
                            VirtualProgram::ShaderMap shaderMap;
                            virtualProgram->getShaderMap(shaderMap);
                            for (auto& s : shaderMap)
                            {
                                ImGui::Text("Name %s", s.second._shader->getName().c_str());
                                ImGui::Text("Location %s", FunctionLocationToString(s.second._shader->getLocation()));
                                ImGui::TextWrapped(s.second._shader->getShaderSource().c_str());
                                ImGui::Separator();
                            }
                            ImGui::TreePop();
                        }

                        ImGui::TreePop();
                    }
                }

                osg::Geometry* geometry = dynamic_cast<osg::Geometry*>(node);
                if (geometry && ImGui::TreeNode("Geometry Properties"))
                {
                    if (geometry->getVertexArray())
                    {
                        ImGui::Text("Vertices %d", geometry->getVertexArray()->getNumElements());
                    }

                    if (geometry->getColorArray())
                    {
                        ImGui::Text("Colors %d", geometry->getColorArray()->getNumElements());
                    }

                    if (geometry->getNormalArray())
                    {
                        ImGui::Text("Normals %d", geometry->getNormalArray()->getNumElements());
                    }

                    for (auto &p : geometry->getPrimitiveSetList())
                    {
                        ImGui::Text("%s Mode=%s Primitives=%d Instances=%d", typeid(*p.get()).name(), GLModeToString(p->getMode()), p->getNumPrimitives(), p->getNumInstances());
                    }
                }
            }

            const char* GLModeToString(GLenum mode)
            {
                switch (mode)
                {
                case(GL_POINTS): return "GL_POINTS";
                case(GL_LINES): return "GL_LINES";
                case(GL_TRIANGLES): return "GL_TRIANGLES";
                case(GL_QUADS): return "GL_QUADS";
                case(GL_LINE_STRIP): return "GL_LINE_STRIP";
                case(GL_LINE_LOOP): return "GL_LINE_LOOP";
                case(GL_TRIANGLE_STRIP): return "GL_TRIANGLE_STRIP";
                case(GL_TRIANGLE_FAN): return "GL_TRIANGLE_FAN";
                case(GL_QUAD_STRIP): return "GL_QUAD_STRIP";
                case(GL_PATCHES): return "GL_PATCHES";
                case(GL_POLYGON): return "GL_POLYGON";
                default: return "Unknown";
                }
            }

            const char* FunctionLocationToString(ShaderComp::FunctionLocation location)
            {
                using namespace osgEarth::ShaderComp;

                switch (location)
                {
                case LOCATION_VERTEX_MODEL: return "LOCATION_VERTEX_MODEL";
                case LOCATION_VERTEX_VIEW: return "LOCATION_VERTEX_VIEW";
                case LOCATION_VERTEX_CLIP: return "LOCATION_VERTEX_CLIP";
                case LOCATION_TESS_CONTROL: return "LOCATION_TESS_CONTROL";
                case LOCATION_TESS_EVALUATION: return "LOCATION_TESS_EVALUATION";
                case LOCATION_GEOMETRY: return "LOCATION_GEOMETRY";
                case LOCATION_FRAGMENT_COLORING: return "LOCATION_FRAGMENT_COLORING";
                case LOCATION_FRAGMENT_LIGHTING: return "LOCATION_FRAGMENT_LIGHTING";
                case LOCATION_FRAGMENT_OUTPUT: return "LOCATION_FRAGMENT_OUTPUT";
                case LOCATION_UNDEFINED: return "LOCATION_UNDEFINED";
                default: return "Undefined";
                }
            }

            osg::MatrixTransform* _selectedBounds;
        };

        struct SelectNodeHandler : public osgGA::GUIEventHandler
        {
            SelectNodeHandler()
            {
            }

            bool handle(const osgGA::GUIEventAdapter& ea, osgGA::GUIActionAdapter& aa)
            {
                osgViewer::View* view = static_cast<osgViewer::View*>(aa.asView());

                if (ea.getEventType() == ea.PUSH && ea.getButton() == ea.LEFT_MOUSE_BUTTON && ea.getModKeyMask() & osgGA::GUIEventAdapter::MODKEY_CTRL)
                {
                    osgUtil::LineSegmentIntersector::Intersections intersections;

                    if (view->computeIntersections(ea, intersections))
                    {
                        double currRatio = DBL_MAX;
                        for (auto& hitr = intersections.begin(); hitr != intersections.end(); ++hitr)
                        {
                            if (hitr->ratio < currRatio)
                            {
                                setSelectedNode(hitr->drawable.get());
                                currRatio = hitr->ratio;
                            }

                        }
                    }
                }
                return false;
            }
        };


        class LayersGUI
        {
        public:
            LayersGUI() :
                _showLog(false),
                _showNetworkMonitor(false),
                _showTextureInspector(false),
                _showSceneHierarchy(false)
            {
            }

            void draw(osg::RenderInfo& renderInfo, osgEarth::MapNode* mapNode, osg::Camera* camera, EarthManipulator* manip)
            {
                if (!_scannedForViewpoints)
                {
                    Config conf = mapNode->getConfig();
                    for (ConfigSet::const_iterator i = conf.children().begin(); i != conf.children().end(); ++i)
                    {
                        if (i->key() == "viewpoints")
                        {
                            const ConfigSet& children = i->children("viewpoint");
                            if (children.size() > 0)
                            {
                                for (ConfigSet::const_iterator i = children.begin(); i != children.end(); ++i)
                                {
                                    _viewpoints.push_back(Viewpoint(*i));
                                }
                            }
                        }
                    }
                    _scannedForViewpoints = true;
                }

                ImGui::Begin("Layers", NULL, ImGuiWindowFlags_MenuBar);

                if (ImGui::BeginMenuBar())
                {
                    if (ImGui::BeginMenu("Tools"))
                    {
                        ImGui::MenuItem("Log", NULL, &_showLog);
                        ImGui::MenuItem("Network Monitor", NULL, &_showNetworkMonitor);
                        ImGui::MenuItem("Texture Inspector", NULL, &_showTextureInspector);
                        ImGui::MenuItem("Scene Hierarchy", NULL, &_showSceneHierarchy);
                        ImGui::EndMenu();
                    }
                    ImGui::EndMenuBar();
                }

                if (_showLog) _log.draw(&_showLog);
                if (_showNetworkMonitor) _networkMonitor.draw(&_showNetworkMonitor);
                if (_showTextureInspector) _textureInspectorGUI.draw(renderInfo, camera, &_showTextureInspector);
                if (_showSceneHierarchy) _sceneHierarchy.draw(((osgViewer::View*)renderInfo.getView())->getSceneData(), renderInfo, manip, mapNode, &_showSceneHierarchy);


                _searchGUI.draw(manip);

                ImGui::Separator();
                ImGuiTabBarFlags tab_bar_flags = ImGuiTabBarFlags_None;
                if (ImGui::BeginTabBar("MyTabBar", tab_bar_flags))
                {
                    if (ImGui::BeginTabItem("Layers"))
                    {
                        ImGui::Text("Layers");
                        osgEarth::VisibleLayerVector layers;
                        mapNode->getMap()->getLayers(layers);

                        for (int i = layers.size() - 1; i >= 0; --i)
                        {
                            osgEarth::Layer* layer = layers[i].get();
                            ImGui::PushID(layer);
                            osgEarth::VisibleLayer *visibleLayer = dynamic_cast<osgEarth::VisibleLayer*>(layer);
                            if (visibleLayer)
                            {
                                bool visible = visibleLayer->getVisible();
                                ImGui::Checkbox(layer->getName().c_str(), &visible);
                                visibleLayer->setVisible(visible);
                            }
                            else
                            {
                                ImGui::Text(layer->getName().c_str());
                            }

                            ImGui::SameLine();
                            if (i > 0)
                            {
                                if (ImGui::ArrowButton("down", ImGuiDir_Down))
                                {
                                    mapNode->getMap()->moveLayer(layer, i - 1);
                                }
                            }
                            if (i < layers.size() - 1)
                            {
                                ImGui::SameLine();
                                if (ImGui::ArrowButton("up", ImGuiDir_Up))
                                {
                                    mapNode->getMap()->moveLayer(layer, i + 1);
                                }
                            }

                            ImGui::SameLine();
                            if (ImGui::ArrowButton("right", ImGuiDir_Right))
                            {
                                const GeoExtent& extent = layer->getExtent();
                                if (extent.isValid())
                                {
                                    std::vector<GeoPoint> points;
                                    points.push_back(GeoPoint(extent.getSRS(), extent.west(), extent.south()));
                                    points.push_back(GeoPoint(extent.getSRS(), extent.east(), extent.north()));

                                    ViewFitter fitter(mapNode->getMap()->getSRS(), camera);
                                    Viewpoint vp;
                                    if (fitter.createViewpoint(points, vp))
                                    {
                                        manip->setViewpoint(vp, 2.0);
                                    }
                                }
                                else if (layer->getNode())
                                {
                                    const osg::BoundingSphere& bs = layer->getNode()->getBound();
                                    if (bs.valid())
                                    {
                                        osg::Vec3d c = bs.center();
                                        double r = bs.radius();
                                        const SpatialReference* mapSRS = mapNode->getMap()->getSRS();

                                        std::vector<GeoPoint> points;
                                        GeoPoint p;
                                        p.fromWorld(mapSRS, osg::Vec3d(c.x() + r, c.y(), c.z())); points.push_back(p);
                                        p.fromWorld(mapSRS, osg::Vec3d(c.x() - r, c.y(), c.z())); points.push_back(p);
                                        p.fromWorld(mapSRS, osg::Vec3d(c.x(), c.y() + r, c.z())); points.push_back(p);
                                        p.fromWorld(mapSRS, osg::Vec3d(c.x(), c.y() - r, c.z())); points.push_back(p);
                                        p.fromWorld(mapSRS, osg::Vec3d(c.x(), c.y(), c.z() + r)); points.push_back(p);
                                        p.fromWorld(mapSRS, osg::Vec3d(c.x(), c.y(), c.z() - r)); points.push_back(p);

                                        ViewFitter fitter(mapNode->getMap()->getSRS(), camera);
                                        Viewpoint vp;
                                        if (fitter.createViewpoint(points, vp))
                                        {
                                            manip->setViewpoint(vp, 2.0);
                                        }
                                    }
                                }
                            }

                            osgEarth::ImageLayer* imageLayer = dynamic_cast<osgEarth::ImageLayer*>(visibleLayer);
                            if (imageLayer)
                            {
                                float opacity = imageLayer->getOpacity();
                                ImGui::PushID("opacity");
                                ImGui::SliderFloat("Opacity", &opacity, 0.0f, 1.0f);
                                imageLayer->setOpacity(opacity);
                                ImGui::PopID();
                            }

                            osgEarth::Contrib::ThreeDTilesLayer* threedTiles = dynamic_cast<osgEarth::Contrib::ThreeDTilesLayer*>(visibleLayer);
                            if (threedTiles)
                            {
                                float sse = threedTiles->getMaximumScreenSpaceError();
                                ImGui::PushID("sse");
                                ImGui::SliderFloat("SSE", &sse, 0.0f, 50.0f);
                                threedTiles->setMaximumScreenSpaceError(sse);
                                ImGui::PopID();

                                ImGui::PushID("debugVolumes");
                                bool showBoundingVolumes = threedTiles->getTilesetNode()->getShowBoundingVolumes();
                                ImGui::Checkbox("Show debug volumes", &showBoundingVolumes);
                                threedTiles->getTilesetNode()->setShowBoundingVolumes(showBoundingVolumes);
                                ImGui::PopID();

                                ImGui::PushID("debugColors");
                                bool colorPerTile = threedTiles->getTilesetNode()->getColorPerTile();
                                ImGui::Checkbox("Show color per tile", &colorPerTile);
                                threedTiles->getTilesetNode()->setColorPerTile(colorPerTile);
                                ImGui::PopID();
                            }
                            ImGui::PopID();

                            ImGui::Separator();
                        }
                        ImGui::EndTabItem();
                    }

                    if (!_viewpoints.empty() && ImGui::BeginTabItem("Viewpoints"))
                    {

                        for (auto& vp : _viewpoints)
                        {
                            ImGui::PushID(&vp);
                            bool selected = false;
                            std::string name = vp.name().get();
                            if (name.empty())
                            {
                                name = "<no name>";
                            }
                            ImGui::Selectable(name.c_str(), &selected);
                            if (selected)
                            {
                                manip->setViewpoint(vp, 2.0);
                            }
                            ImGui::PopID();
                        }
                        ImGui::EndTabItem();
                    }
                }
                ImGui::End();
            }

            bool _showLog;
            bool _showNetworkMonitor;
            bool _showTextureInspector;
            bool _showSceneHierarchy;
            LogGUI _log;
            NetworkMonitorGUI _networkMonitor;
            SearchGUI _searchGUI;
            TextureInspectorGUI _textureInspectorGUI;
            SceneHierarchy _sceneHierarchy;

            std::vector< Viewpoint > _viewpoints;
            bool _scannedForViewpoints = false;
        };
    }
}



#endif
