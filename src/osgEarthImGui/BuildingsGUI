/* osgEarth
 * Copyright 2025 Pelican Mapping
 * MIT License
 */
#pragma once

#include <osgEarthImGui/ImGuiPanel>
#include <osgEarthBuildings/BuildingLayer>
#include <osgEarthBuildings/Parapet>

using namespace osgEarth::Buildings;

namespace osgEarth
{
    class BuildingsGUI : public ImGuiPanel
    {
    private:
        osg::observer_ptr<MapNode> _mapNode;
        std::vector<osg::observer_ptr<BuildingLayer>> _buildingLayers;
        int _selectedLayerIndex;
        char _nameFilter[256];
        char _tagFilter[256];
        float _heightFilter;
        float _areaFilter;
        bool _enableHeightFilter;
        bool _enableAreaFilter;

    public:
        BuildingsGUI() :
            ImGuiPanel("Buildings"),
            _selectedLayerIndex(0),
            _heightFilter(0.0f),
            _areaFilter(0.0f),
            _enableHeightFilter(false),
            _enableAreaFilter(false)
        {
            memset(_nameFilter, 0, sizeof(_nameFilter));
            memset(_tagFilter, 0, sizeof(_tagFilter));
        }

        void load(const Config& conf) override
        {
            conf.get("SelectedLayerIndex", _selectedLayerIndex);
            conf.get("Height", _heightFilter);
            conf.get("Area", _areaFilter);
            conf.get("EnableHeightFilter", _enableHeightFilter);
            conf.get("EnableAreaFilter", _enableAreaFilter);
            std::string name;
            if (conf.get("Name", name))
            {
                strncpy(_nameFilter, name.c_str(), sizeof(_nameFilter) - 1);
            }
            std::string tags;
            if (conf.get("Tags", tags))
            {
                strncpy(_tagFilter, tags.c_str(), sizeof(_tagFilter) - 1);
            }
        }

        void save(Config& conf) override
        {
            conf.set("SelectedLayerIndex", _selectedLayerIndex);
            conf.get("Height", _heightFilter);
            conf.get("Area", _areaFilter);
            conf.set("EnableHeightFilter", _enableHeightFilter);
            conf.set("EnableAreaFilter", _enableAreaFilter);
            conf.set("Name", std::string(_nameFilter));
            conf.set("Tags", std::string(_tagFilter));
        }

        void draw(osg::RenderInfo& ri) override
        {
            if (!isVisible()) return;
            if (!findNodeOrHide(_mapNode, ri)) return;

            // Fetch all BuildingLayers from the map
            _buildingLayers.clear();
            LayerVector layers;
            _mapNode->getMap()->getLayers(layers);
            for (LayerVector::const_iterator itr = layers.begin(); itr != layers.end(); ++itr)
            {
                BuildingLayer* layer = dynamic_cast<BuildingLayer*>(itr->get());
                if (layer)
                {
                    _buildingLayers.push_back(layer);
                }
            }

            // Clamp selected index to valid range
            if (_selectedLayerIndex >= (int)_buildingLayers.size())
            {
                _selectedLayerIndex = 0;
            }

            if (ImGui::Begin(name(), visible(), ImGuiWindowFlags_NoScrollbar))
            {
                if (_buildingLayers.empty())
                {
                    ImGui::Text("No BuildingLayer found in Map.");
                }
                else
                {
                    // Get the current layer
                    BuildingLayer* currentLayer = _buildingLayers[_selectedLayerIndex].get();

                    // Add dropdown to select BuildingLayer
                    if (_buildingLayers.size() > 1)
                    {
                        ImGui::Text("Select Building Layer:");
                        ImGui::SameLine();
                        if (ImGui::BeginCombo("##layerselect", currentLayer->getName().c_str()))
                        {
                            for (int i = 0; i < (int)_buildingLayers.size(); ++i)
                            {
                                bool isSelected = (i == _selectedLayerIndex);
                                if (ImGui::Selectable(_buildingLayers[i]->getName().c_str(), isSelected))
                                {
                                    _selectedLayerIndex = i;
                                }
                                if (isSelected)
                                {
                                    ImGui::SetItemDefaultFocus();
                                }
                            }
                            ImGui::EndCombo();
                        }
                    }

                    ImGui::Text("Building layer: %s", currentLayer->getName().c_str());
                    ImGui::Text("Catalog: %s", currentLayer->getBuildingCatalog()->getURI().full().c_str());

                    // Filter controls
                    ImGui::Text("Name:");
                    ImGui::SameLine();
                    ImGui::SetNextItemWidth(200);
                    ImGui::InputText("##name", _nameFilter, 256);

                    ImGui::SameLine();
                    ImGui::Text("Tags:");
                    ImGui::SameLine();
                    ImGui::SetNextItemWidth(300);
                    ImGui::InputText("##tags", _tagFilter, 256);

                    ImGui::Checkbox("Height Filter", &_enableHeightFilter);
                    ImGui::SameLine();
                    ImGui::BeginDisabled(!_enableHeightFilter);
                    ImGui::SetNextItemWidth(100);
                    ImGui::InputFloat("##height", &_heightFilter, 0.0f, 0.0f, "%.2f");
                    ImGui::EndDisabled();       
                    
                    ImGui::Checkbox("Area Filter", &_enableAreaFilter);
                    ImGui::SameLine();
                    ImGui::BeginDisabled(!_enableAreaFilter);
                    ImGui::SetNextItemWidth(100);
                    ImGui::InputFloat("##area", &_areaFilter, 0.0f, 0.0f, "%.2f");
                    ImGui::EndDisabled();

                    // Parse tags filter
                    TagVector filterTags;
                    if (strlen(_tagFilter) > 0)
                    {
                        std::string tagsStr(_tagFilter);

                        filterTags = StringTokenizer()
                            .delim(" ")
                            .standardQuotes()
                            .keepEmpties(false)
                            .tokenize(tagsStr);
                    }

                    ImVec2 availableContent = ImGui::GetContentRegionAvail();
                    ImVec2 textSize = ImGui::CalcTextSize("A");
                    ImVec2 tableSize(0, availableContent.y - textSize.y);

                    unsigned int filteredCount = 0;

                    if (ImGui::BeginTable("BuildingTable", 7, ImGuiTableFlags_ScrollY | ImGuiTableFlags_SizingFixedFit | ImGuiTableFlags_Resizable | ImGuiTableFlags_NoSavedSettings | ImGuiTableFlags_Borders, tableSize))
                    {
                        ImGui::TableSetupScrollFreeze(0, 1);
                        ImGui::TableSetupColumn("Name", ImGuiTableColumnFlags_WidthFixed, 200.0f);
                        ImGui::TableSetupColumn("Instanced", ImGuiTableColumnFlags_WidthFixed, 80.0f);
                        ImGui::TableSetupColumn("Min Height", ImGuiTableColumnFlags_WidthFixed, 100.0f);
                        ImGui::TableSetupColumn("Max Height", ImGuiTableColumnFlags_WidthFixed, 100.0f);
                        ImGui::TableSetupColumn("Min Area", ImGuiTableColumnFlags_WidthFixed, 100.0f);
                        ImGui::TableSetupColumn("Max Area", ImGuiTableColumnFlags_WidthFixed, 100.0f);
                        ImGui::TableSetupColumn("Tags", ImGuiTableColumnFlags_WidthStretch);
                        ImGui::TableHeadersRow();

                        for (BuildingVector::const_iterator itr = currentLayer->getBuildingCatalog()->getBuildings().begin();
                            itr != currentLayer->getBuildingCatalog()->getBuildings().end(); ++itr)
                        {
                            const Building* building = *itr;

                            // Apply filters
                            if (strlen(_nameFilter) > 0)
                            {
                                std::string buildingName = building->getName();
                                if (buildingName.find(_nameFilter) == std::string::npos)
                                    continue;
                            }

                            if (!filterTags.empty() && !building->containsTags(filterTags))
                                continue;

                            if (_enableHeightFilter && (_heightFilter < building->getMinHeight() || _heightFilter > building->getMaxHeight()))
                                continue;

                            if (_enableAreaFilter && (_areaFilter < building->getMinArea() || _areaFilter > building->getMaxArea()))
                                continue;

                            filteredCount++;

                            ImGui::TableNextColumn();
                            ImGui::Text("%s", building->getName().c_str());

                            ImGui::TableNextColumn();
                            ImGui::Text("%s", building->getInstanced() ? "true" : "false");

                            ImGui::TableNextColumn();
                            ImGui::Text("%.2f", building->getMinHeight());

                            ImGui::TableNextColumn();
                            ImGui::Text("%.2f", building->getMaxHeight());

                            ImGui::TableNextColumn();
                            ImGui::Text("%.2f", building->getMinArea());
                            ImGui::TableNextColumn();
                            ImGui::Text("%.2f", building->getMaxArea());

                            ImGui::TableNextColumn();
                            ImGui::Text("%s", building->tagString().c_str());
                        }

                        ImGui::EndTable();
                    }

                    ImGui::Text("%d / %d buildings", filteredCount, (int)currentLayer->getBuildingCatalog()->getBuildings().size());
                }

                ImGui::End();
            }
        }
    };
}
